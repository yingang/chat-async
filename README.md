# chat-async

为啥会有这个项目：
* 前面一个月几乎一口气把《Rust程序设计》第二版读完了，但纸上读来终觉浅，为避免读书一时爽读后忘光光，想着自己试着把书上的一些例子自己实现一遍，应该会有更好的学习效果吧
* 这个例子是基于异步通信实现的 C/S 网络通信，以后如果学习其它语言/类库的异步机制，应该也可以继续用这个场景
* 然后我的实现和书上的实现会类似（毕竟看过书，多少有些记忆还在），但也不太一样（直接抄作业的学习效果也不会好）

试验步骤（可对照提交记录）：
1. 基本的 TCP 通信，客户端发送固定内容后退出
   * 这段基本参照 `async_std` 文档里的样例改改就行了
   * thread::spawn 是接收一个闭包，`task::spawn` 或 `task::spawn_local` 是接收一个异步块
2. 支持客户端在终端交互输入要发往服务端的信息
   * 这段主要是额外再 `spawn` 一个接收服务端消息的异步块
   * 过程中碰到的问题主要是消息接收循环退出了也没发现。。。调试阶段适当多加点输出
3. 支持客户端特定的信息发送格式，并用 `JSON` 进行序列化
   * `serde` 系还是挺好用的，参照文档样例来就好了
4. 支持服务端的消息处理和按群组转发
   * `spawn` 和 `spawn_local` 还是有区别的，简单起见，先玩 `spawn_local`（需要启用 `async_std` 的 `unstable`）
   * 但即使不用多线程，要在服务端维护一个公共的群组结构还挺麻烦，反复尝试后用 `Rc<Mutex<T>>` 搞定的
     * 感觉这里应该不能用 `std` 的 `Mutex` 了，但编译没报任何错误？
5. 服务端改成多线程（线程池）的版本
   * `spawn_local` 换成 `spawn`，`Rc` 换成 `Arc`，`Mutex` 也换成 `async_std` 里的
   * 服务端发送的消息也结构化了

初步完成后，还是有一些收获的，除了很基础的异步编程，类似于代码结构组织、对象序列化等都有一些初步的了解。